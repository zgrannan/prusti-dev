window.SIDEBAR_ITEMS = {"attr":[["after_expiry","A macro for writing a pledge on a function."],["assert_on_expiry","A macro for writing a two-state pledge on a function."],["ensures","A macro for writing a postcondition on a function."],["extern_spec","A macro for specifying external functions."],["ghost_constraint","A macro to add trait bounds on a generic type parameter and specifications which are active only when these bounds are satisfied for a call."],["invariant","A macro for type invariants."],["model","Macro for creating type models."],["pure","A macro for marking a function as pure."],["refine_trait_spec","A macro for impl blocks that refine trait specifications."],["requires","A macro for writing a precondition on a function."],["trusted","A macro for marking a function as trusted."]],"fn":[["before_expiry","This function is used to evaluate an expression in the context just before the borrows expires."],["exists",""],["forall",""],["old","This function is used to evaluate an expression in the “old” context, that is at the beginning of the method call."],["prusti_set_union_active_field",""]],"macro":[["body_invariant","A macro for writing a loop body invariant."],["closure","A macro for defining a closure with a specification."],["ghost","A macro for defining ghost blocks which will be left in for verification but omitted during compilation."],["map",""],["predicate","A macro for defining a predicate using prusti expression syntax instead of just Rust expressions."],["prusti_assert","A macro for writing assertions using the full prusti specifications"],["prusti_assume","A macro for writing assumptions using prusti syntax"],["seq",""]],"struct":[["Ghost",""],["Int","a mathematical (unbounded) integer type it should not be constructed from running rust code, hence the private unit inside"],["Map","A map type"],["Seq","A sequence type"]]};