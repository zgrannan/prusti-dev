<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Push - Prusti user guide</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../basic.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="../tour/summary.html"><strong aria-hidden="true">4.</strong> Guided Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tour/getting-started.html"><strong aria-hidden="true">4.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../tour/new.html"><strong aria-hidden="true">4.2.</strong> New</a></li><li class="chapter-item expanded "><a href="../tour/push.html" class="active"><strong aria-hidden="true">4.3.</strong> Push</a></li><li class="chapter-item expanded "><a href="../tour/pop.html"><strong aria-hidden="true">4.4.</strong> Pop</a></li><li class="chapter-item expanded "><a href="../tour/testing.html"><strong aria-hidden="true">4.5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../tour/bad-stack.html"><strong aria-hidden="true">4.6.</strong> A Bad Stack</a></li><li class="chapter-item expanded "><a href="../tour/options.html"><strong aria-hidden="true">4.7.</strong> Options</a></li><li class="chapter-item expanded "><a href="../tour/generics.html"><strong aria-hidden="true">4.8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../tour/peek.html"><strong aria-hidden="true">4.9.</strong> Peek</a></li><li class="chapter-item expanded "><a href="../tour/final.html"><strong aria-hidden="true">4.10.</strong> Final Code</a></li><li class="chapter-item expanded "><a href="../tour/pledges.html"><strong aria-hidden="true">4.11.</strong> Pledges</a></li></ol></li><li class="chapter-item expanded "><a href="../verify/summary.html"><strong aria-hidden="true">5.</strong> Verification Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verify/panic.html"><strong aria-hidden="true">5.1.</strong> Absence of panics</a></li><li class="chapter-item expanded "><a href="../verify/overflow.html"><strong aria-hidden="true">5.2.</strong> Overflow checks</a></li><li class="chapter-item expanded "><a href="../verify/prepost.html"><strong aria-hidden="true">5.3.</strong> Pre- and postconditions</a></li><li class="chapter-item expanded "><a href="../verify/assert_assume.html"><strong aria-hidden="true">5.4.</strong> Assertions and assumptions</a></li><li class="chapter-item expanded "><a href="../verify/trusted.html"><strong aria-hidden="true">5.5.</strong> Trusted functions</a></li><li class="chapter-item expanded "><a href="../verify/pure.html"><strong aria-hidden="true">5.6.</strong> Pure functions</a></li><li class="chapter-item expanded "><a href="../verify/predicate.html"><strong aria-hidden="true">5.7.</strong> Predicates</a></li><li class="chapter-item expanded "><a href="../verify/external.html"><strong aria-hidden="true">5.8.</strong> External specifications</a></li><li class="chapter-item expanded "><a href="../verify/loop.html"><strong aria-hidden="true">5.9.</strong> Loop body invariants</a></li><li class="chapter-item expanded "><a href="../verify/pledge.html"><strong aria-hidden="true">5.10.</strong> Pledges</a></li><li class="chapter-item expanded "><a href="../verify/traits.html"><strong aria-hidden="true">5.11.</strong> Trait contract refinement</a></li><li class="chapter-item expanded "><a href="../verify/closure.html"><strong aria-hidden="true">5.12.</strong> Closures</a></li><li class="chapter-item expanded "><a href="../verify/spec_ent.html"><strong aria-hidden="true">5.13.</strong> Specification entailments</a></li><li class="chapter-item expanded "><a href="../verify/type-models.html"><strong aria-hidden="true">5.14.</strong> Type models</a></li><li class="chapter-item expanded "><a href="../verify/print_counterexample.html"><strong aria-hidden="true">5.15.</strong> Customizable counterexample</a></li></ol></li><li class="chapter-item expanded "><a href="../syntax.html"><strong aria-hidden="true">6.</strong> Specification Syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prusti user guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="push"><a class="header" href="#push">Push</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong> 
<a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a></p>
</blockquote>
<h2 id="informal-specifications"><a class="header" href="#informal-specifications">Informal specifications</a></h2>
<p>Our next goal is to implement and verify a method that pushes an integer onto a list.
In contrast to methods like <code>len</code>, <code>push</code> modifies the list; it thus takes
<code>&amp;mut self</code> as its first argument:</p>
<pre><code class="language-rust noplaypen">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
</code></pre>
<p>Before we implement <code>push</code>, let us briefly think of possible specifications.
Ideally, our implementation satisfies at least the following properties:</p>
<ol>
<li>Executing <code>push</code> increases the length of the underlying list by one.</li>
<li>After <code>push(elem)</code> the first element of the list stores the value <code>elem</code>.</li>
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged.</li>
</ol>
<h2 id="first-property"><a class="header" href="#first-property">First property</a></h2>
<p>The first property can easily be expressed as a postcondition that uses the
pure method <code>len</code> introduced in the <a href="new.html">previous chapter</a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>The above postcondition depends on <em>two</em> states, namely the state before and after
execution of <code>self.push(elem)</code>, respectively.
We use an <a href="../syntax.html#old-expressions">old expression</a>
to refer to the state before execution of <code>self.push(elem)</code>.
Since we have not implemented <code>push</code> yet, Prusti will, unsurprisingly, complain:</p>
<pre><code>[Prusti: verification error] postcondition might not hold.
</code></pre>
<h2 id="implementing-push"><a class="header" href="#implementing-push">Implementing Push</a></h2>
<p>Conceptually, implementing <code>list.push(i)</code> should be straightforward:
we create a new instance of our struct for list nodes that stores
<code>i</code> in its <code>elem</code> field and the original list in its <code>next</code> field.
We may thus be tempted to write the following:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head,
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>Unfortunately, the Rust compiler will complain about this attempt:</p>
<pre><code>[E0507] cannot move out of `self.head` which is behind a mutable reference.
</code></pre>
<p><code>self</code> is a mutable borrow, meaning once it expires ownership to the referenced data
returns to the original owner.
However, we moved parts of those, the original list, into our newly created node.
This would leave the borrow in a partially initialized state when it expires and would
not allow us to return ownership.
Hence, the compiler raises an error.
See <a href="https://rust-unofficial.github.io/too-many-lists/first-ownership.html">2.3: Ownership 101</a>
and <a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a>
in the Rust tutorial for details. </p>
<p>A working alternative exploits that <code>self</code> is a <em>mutable</em> borrow which allows
us to completely overwrite the referenced data.
Instead of moving the original list into the new node, we <em>swap</em> it 
with an empty list that can be returned to the owner once the borrow expires.
The <a href="https://doc.rust-lang.org/std/mem/fn.replace.html">Rust standard library</a>
provides the function <code>std::mem::replace</code> for that purpose - it moves its second
argument into the referenced first argument and returns the originally referenced value.
Using this function, the Rust compiler accepts the following implementation:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>use std::mem;

<span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>In fact, the above implementation of <code>push</code> is correct.
However, attempting to verify it with Prusti still yields a verification error:</p>
<pre><code>[Prusti: verification error] postcondition might not hold.
</code></pre>
<p>This error may look surprising at first: 
We create a new list node that stores the the original list in its next field.
Why is Prusti unable to realize that the length of the resulting list
is one plus the length of the original list?</p>
<p>The explanation is that Prusti performs <em>function modular</em> verification, 
that is, it only uses a function's specification (instead of also consulting the 
function's implementation) whenever it encounters a function call.
The only exception are <em>pure</em> functions, such as <code>len</code>, where Prusti also takes the
function body into account.</p>
<p>In our case, the function <code>std::mem::replace</code> is neither marked as <code>pure</code> nor does it
come with a specification. Hence, Prusti assumes that it is memory safe and nothing else.
That is, Prusti uses <code>true</code> as both pre- and postcondition of <code>std::mem::replace</code>,
which is too weak to prove the specification of <code>push</code>: according to its specification,
<code>std::mem::replace</code> could arbitrarily change the original list and thus also its length.
Hence, we cannot conclude that the length the list returned by
<code>mem::replace(&amp;mut self.head, Link::Empty)</code> coincides with the length of the original 
list.</p>
<p>We can remedy this issue by strengthening the specification of <code>std::mem::replace</code>.
In this tutorial, we will assume that the standard library is correct, that is, we 
do not attempt to verify specifications for functions in external crates, 
like <code>std::mem::replace</code>.
To this end, we introduce a <a href="../verify/trusted.html">trusted</a> wrapper function <code>replace</code>
that calls <code>std::mem::replace</code> and is equipped with the desired specification.
The attribute <code>#[trusted]</code> tells Prusti to assume the provided specification is correct
without attempting to verify it against a function's body.</p>
<p>After introducing a trusted wrapper that ensures that <code>replace</code> does not change the 
length of the original list, the following implementation verifies:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[trusted]
#[ensures(old(dest.len()) == result.len())]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span>// Prusti: VERIFIES
</code></pre>
<p>Trusted functions are useful for dealing with external code, like <code>std::mem::replace</code>, 
or constructs that are not yet supported by Prusti.
<strong>However, a single incorrect specification of a trusted function can invalidate the
correctness of Prusti as a whole!</strong>
Hence, trusted functions, like unsafe Rust code, need to be treated carefully and 
require external justification.</p>
<p>It is good practice to provide strong preconditions for trusted functions 
to reduce the chance that they are accidentially called with unintended arguments.
In our case, we could additionally require that <code>replace</code> always takes an empty
list as its second argument.
We formalize this precondition by introducing another pure function <code>is_empty</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

<span class="boring">impl List {
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">   pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">       let new_node = Box::new(Node {
</span><span class="boring">           elem: elem,
</span><span class="boring">           next: replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">       });
</span><span class="boring">
</span><span class="boring">       self.head = Link::More(new_node);
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>impl Link {
<span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        match self {
            Link::Empty =&gt; true,
            Link::More(box node) =&gt; false,
        }
    }
}
// Prusti: VERIFIES
</code></pre>
<p>This completes our implementation of <code>push</code> but we still need to verify
the remaining properties of its specification.</p>
<h2 id="second-property"><a class="header" href="#second-property">Second property</a></h2>
<p>Recall that the second property of our specification informally reads as follows:</p>
<blockquote>
<ol start="2">
<li>After <code>push(elem)</code> the first element of the list stores the value <code>elem</code>.</li>
</ol>
</blockquote>
<p>To formally specify the above property, we first introduce another pure function, called 
<code>lookup</code>, that recursively traverses the list and returns its i-th element.
Our second desired property then corresponds to the postcondition 
<code>self.lookup(0) == elem</code>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[trusted]
</span><span class="boring">#[ensures(old(dest.len()) == result.len())]
</span><span class="boring">fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
</span><span class="boring">   mem::replace(dest, src)
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span>    
    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)]
    pub fn push(&amp;mut self, elem: i32) {
        // ...
<span class="boring">       let new_node = Box::new(Node {
</span><span class="boring">           elem: elem,
</span><span class="boring">           next: replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">       });
</span><span class="boring">       self.head = Link::More(new_node);
</span>    }
}

impl Link {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::More(box node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            },
            Link::Empty =&gt; unreachable!(),  
        }
    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span>}
</code></pre>
<p>Consider the <code>match</code> statement in the last function.
The Rust compiler will complain if we attempt to omit the case <code>Link::Empty</code>.
Since there is no sensible implementation of <code>lookup</code> if the underlying list is empty,
we used the macro <code>unreachable!()</code>, which will crash the program with a panic.
Since nothing prevents us from calling <code>lookup</code> on an empty list, Prusti complains:</p>
<pre><code>unreachable!(..) statement in pure function might be reachable
</code></pre>
<p>We can specify that <code>lookup</code> should only be called on non-empty lists by adding the 
precondition <code>0 &lt;= index &amp;&amp; index &lt; self.len()</code> to <em>both</em> <code>lookup</code> functions; this is 
sufficient to verify our second property for <code>push</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[trusted]
</span><span class="boring">#[ensures(old(dest.len()) == result.len())]
</span><span class="boring">fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
</span><span class="boring">   mem::replace(dest, src)
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">   pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">       let new_node = Box::new(Node {
</span><span class="boring">           elem: elem,
</span><span class="boring">           next: replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">       });
</span><span class="boring">       self.head = Link::More(new_node);
</span><span class="boring">   }
</span>}

impl Link {
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        // ...
<span class="boring">       match self {
</span><span class="boring">           Link::More(box node) =&gt; {
</span><span class="boring">               if index == 0 {
</span><span class="boring">                   node.elem
</span><span class="boring">               } else {
</span><span class="boring">                   node.next.lookup(index - 1)
</span><span class="boring">               }
</span><span class="boring">           },
</span><span class="boring">           Link::Empty =&gt; unreachable!(),
</span><span class="boring">       }
</span>    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span>}
// Prusti: VERIFIES
</code></pre>
<h2 id="third-property"><a class="header" href="#third-property">Third property</a></h2>
<p>The third and final property we will verify for <code>push</code> is that the original list
content is not modified:</p>
<blockquote>
<ol start="3">
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged.</li>
</ol>
</blockquote>
<p>To formalize the above property, we can reuse our pure function <code>lookup</code>, 
<a href="../syntax.html#quantifiers">quantifiers</a>, and <a href="../syntax.html#old-expressions">old expressions</a>, that is, we add
the postcondition:</p>
<pre><code class="language-rust noplaypen">#[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
             old(self.lookup(i - 1)) == self.lookup(i)))] 
pub fn push(&amp;mut self, elem: i32) {
    // ...
}
</code></pre>
<p>After adding the above postcondition, Prusti will complain that the postcondition
might not hold; the reason is similar to an issue we encountered when verifying
the first property: the specification of <code>replace</code> is too weak.
Verification succeeds after adding the same postcondition to <code>replace</code>.
We conclude this section with the full code for verifying <code>push</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
#[ensures(forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; result.len()) ==&gt;
                old(dest.lookup(i)) == result.lookup(i)))]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

impl List {
<span class="boring">   #[pure]
</span><span class="boring">   #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
</span><span class="boring">   pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">       self.head.lookup(index)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)]
    #[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
                old(self.lookup(i-1)) == self.lookup(i)))]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
</span><span class="boring">   pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; unreachable!(),
</span><span class="boring">           Link::More(box node) =&gt; {
</span><span class="boring">               if index == 0 {
</span><span class="boring">                   node.elem
</span><span class="boring">               } else {
</span><span class="boring">                   node.next.lookup(index - 1)
</span><span class="boring">               }
</span><span class="boring">           },
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   #[ensures(!self.is_empty() ==&gt; result &gt; 0)]
</span><span class="boring">   #[ensures(result &gt;= 0)]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; true,
</span><span class="boring">           Link::More(box node) =&gt; false,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span>// Prusti: VERIFIES
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tour/new.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../tour/pop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tour/new.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../tour/pop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
