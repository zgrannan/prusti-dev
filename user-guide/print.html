<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prusti user guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="basic.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="tour/summary.html"><strong aria-hidden="true">4.</strong> Guided Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tour/getting-started.html"><strong aria-hidden="true">4.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="tour/new.html"><strong aria-hidden="true">4.2.</strong> New</a></li><li class="chapter-item expanded "><a href="tour/push.html"><strong aria-hidden="true">4.3.</strong> Push</a></li><li class="chapter-item expanded "><a href="tour/pop.html"><strong aria-hidden="true">4.4.</strong> Pop</a></li><li class="chapter-item expanded "><a href="tour/testing.html"><strong aria-hidden="true">4.5.</strong> Testing</a></li><li class="chapter-item expanded "><a href="tour/bad-stack.html"><strong aria-hidden="true">4.6.</strong> A Bad Stack</a></li><li class="chapter-item expanded "><a href="tour/options.html"><strong aria-hidden="true">4.7.</strong> Options</a></li><li class="chapter-item expanded "><a href="tour/generics.html"><strong aria-hidden="true">4.8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="tour/peek.html"><strong aria-hidden="true">4.9.</strong> Peek</a></li><li class="chapter-item expanded "><a href="tour/final.html"><strong aria-hidden="true">4.10.</strong> Final Code</a></li><li class="chapter-item expanded "><a href="tour/pledges.html"><strong aria-hidden="true">4.11.</strong> Pledges</a></li></ol></li><li class="chapter-item expanded "><a href="verify/summary.html"><strong aria-hidden="true">5.</strong> Verification Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="verify/panic.html"><strong aria-hidden="true">5.1.</strong> Absence of panics</a></li><li class="chapter-item expanded "><a href="verify/overflow.html"><strong aria-hidden="true">5.2.</strong> Overflow checks</a></li><li class="chapter-item expanded "><a href="verify/prepost.html"><strong aria-hidden="true">5.3.</strong> Pre- and postconditions</a></li><li class="chapter-item expanded "><a href="verify/assert_assume.html"><strong aria-hidden="true">5.4.</strong> Assertions and assumptions</a></li><li class="chapter-item expanded "><a href="verify/trusted.html"><strong aria-hidden="true">5.5.</strong> Trusted functions</a></li><li class="chapter-item expanded "><a href="verify/pure.html"><strong aria-hidden="true">5.6.</strong> Pure functions</a></li><li class="chapter-item expanded "><a href="verify/predicate.html"><strong aria-hidden="true">5.7.</strong> Predicates</a></li><li class="chapter-item expanded "><a href="verify/external.html"><strong aria-hidden="true">5.8.</strong> External specifications</a></li><li class="chapter-item expanded "><a href="verify/loop.html"><strong aria-hidden="true">5.9.</strong> Loop body invariants</a></li><li class="chapter-item expanded "><a href="verify/pledge.html"><strong aria-hidden="true">5.10.</strong> Pledges</a></li><li class="chapter-item expanded "><a href="verify/traits.html"><strong aria-hidden="true">5.11.</strong> Trait contract refinement</a></li><li class="chapter-item expanded "><a href="verify/closure.html"><strong aria-hidden="true">5.12.</strong> Closures</a></li><li class="chapter-item expanded "><a href="verify/spec_ent.html"><strong aria-hidden="true">5.13.</strong> Specification entailments</a></li><li class="chapter-item expanded "><a href="verify/type-models.html"><strong aria-hidden="true">5.14.</strong> Type models</a></li><li class="chapter-item expanded "><a href="verify/print_counterexample.html"><strong aria-hidden="true">5.15.</strong> Customizable counterexample</a></li></ol></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">6.</strong> Specification Syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prusti user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the user guide for <a href="https://github.com/viperproject/prusti-dev/">Prusti</a> - a Rust verifier built upon the the <a href="https://www.pm.inf.ethz.ch/research/viper.html">Viper verification infrastructure</a>.
This guide replaces the <a href="https://github.com/viperproject/prusti-dev/wiki/Tutorial">wiki-based tutorial</a> from the GitHub repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="prusti-assistant"><a class="header" href="#prusti-assistant">Prusti Assistant</a></h2>
<p>The easiest way to try out Prusti is by using the <a href="https://marketplace.visualstudio.com/items?itemName=viper-admin.prusti-assistant">&quot;Prusti Assistant&quot;</a> extension for <a href="https://code.visualstudio.com/">Visual Studio Code</a>. Please confer the extension's webpage for detailed installation instructions.</p>
<p>To update the currently installed version of Prusti within Prusti Assistant, it suffices to open the <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">Command Palette</a> and run the command <code>Prusti: update dependencies</code>.</p>
<blockquote>
<p><strong>Warning:</strong> Some of the Prusti-specific syntax described in this guide is currently only available in the &quot;nightly&quot; build channel, which corresponds to the latest development version of Prusti.
The settings for switching to this version in Prusti Assistant are found in
<code>File → Preferences → Settings → Prusti Assistant → Build Channel</code>.</p>
</blockquote>
<h2 id="command-line-setup"><a class="header" href="#command-line-setup">Command-line setup</a></h2>
<p>Alternatively, Prusti can be set up by downloading the <a href="https://github.com/viperproject/prusti-dev/releases">precompiled binaries</a> available from the project page. We currently provide binaries for Windows, macOS, and Ubuntu. Releases marked as &quot;Pre-release&quot; may contain unstable or experimental features.</p>
<p>For a command-line setup with Prusti built from source, please confer the <a href="https://viperproject.github.io/prusti-dev/dev-guide/development/setup.html">developer guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<h2 id="prusti-assistant-1"><a class="header" href="#prusti-assistant-1">Prusti Assistant</a></h2>
<p>When the Prusti Assistant extension is active, Rust files can be verified in one of the following ways:</p>
<ul>
<li>By clicking the &quot;Verify with Prusti&quot; button in the status bar.</li>
<li>By opening the <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">Command Palette</a> and running the command &quot;Prusti: save and verify this file&quot;.</li>
<li>By saving a Rust document, if &quot;Verify on save&quot; is enabled.</li>
<li>By opening a Rust document, if &quot;Verify on open&quot; is enabled.</li>
</ul>
<p>See the <a href="verify/summary.html">following chapter</a> for a list of verification features available in Prusti.</p>
<h2 id="command-line"><a class="header" href="#command-line">Command line</a></h2>
<p>To run Prusti on a file using the command-line setup:</p>
<pre><code class="language-bash">$ prusti-rustc --edition=2018 path/to/file.rs
</code></pre>
<h2 id="introductory-example"><a class="header" href="#introductory-example">Introductory example</a></h2>
<p>Let us verify that the function <code>max</code> below, which takes two integers and returns the greater one, is implemented correctly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When pasting the above code into a Rust file and then verifying it with Prusti (as outlined at the top of the page), Prusti should report that verification succeeded.
This tells us that</p>
<ol>
<li>the file consists of valid Rust code that can be compiled successfuly, and</li>
<li>no execution reaches a Rust panic (explicit call of the <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!()</code></a> macro, a failed assertion, etc).</li>
</ol>
<p>To also verify that <code>max</code> indeed always returns the maximum of its two inputs, we have to add a corresponding specification, which states
that the return value of <code>max</code> is at least as large as both <code>a</code> and <code>b</code> and, additionally, coincides with <code>a</code> or <code>b</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[ensures(result &gt;= a &amp;&amp; result &gt;= b)]
#[ensures(result == a || result == b)]
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the above program, the first line (<code>use prusti_contracts::*;</code>) simplifies writing Prusti-specific syntax for specifications; allowing us to write <code>#[ensures(...)]</code> instead of <code>#[prusti_contracts::ensures(...)]</code>.</p>
<blockquote>
<p><strong>Warning:</strong> Due to limitations in Rust procedural macros, <code>use prusti_contracts::*;</code> should <em>always</em> be used, and the Prusti specification attributes should not be imported with an alias.</p>
</blockquote>
<p>After that, we used <code>#[ensures(...)]</code> to attach two <a href="verify/prepost.html">postconditions</a> to the function <code>max</code>. 
The syntax of specifications is a superset of Rust expressions, where <code>result</code> is a keyword referring to the function's return value. </p>
<p>Again, verifying the above code with Prusti should succeed. 
Notice that Prusti assumes by default that integer types are bounded; it thus performs <a href="verify/overflow.html">overflow and underflow checks</a> unless corresponding options are provided.</p>
<p>Next, we add a second function <code>max3</code> which returns the maximum of three instead of two integers; we reuse the already verified function <code>max</code> in the new function's specification to show that this function is implemented correctly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[pure]
#[ensures(result &gt;= a &amp;&amp; result &gt;= b)]
#[ensures(result == a || result == b)]
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}

#[ensures(result == max(a, max(b, c)))]
fn max3(a: i32, b: i32, c: i32) -&gt; i32 {
    if a &gt; b &amp;&amp; a &gt; c {
        a
    } else {
        if b &gt; c {
            b
        } else {
            c
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Again, Prusti should successfully verify the above program.
Notice that we additionally declared the function <code>max</code> as <a href="verify/pure.html">pure</a> such that it can be used within specifications.
If we omit this annotation, Prusti will complain that the postcondition of function <code>max3</code> is invalid because it uses an <code>impure</code> function, which may potentially have side-effects.</p>
<p>So far, we only considered programs that meet their specification and that, consequently, Prusti successfully verified.
To conclude this example, assume we accidentally return <code>c</code> instead of <code>b</code> if <code>b &gt; c</code> holds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ensures(result == max(a, max(b, c)))]
fn max3(a: i32, b: i32, c: i32) -&gt; i32 {
    if a &gt; b &amp;&amp; a &gt; c {
        a
    } else {
        if b &gt; c {
            c // ERROR
        } else {
            c
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, Prusti will highlight the line with the error and report that the <code>postcondition might not hold</code>.</p>
<p>For debugging purposes, it is often useful to add <code>assert!(...)</code> macros to our code to locate the issue. For example, in the code below, we added an assertion that fails because <code>b &gt; c</code> and thus the maximum of <code>b</code> and <code>c</code> is <code>b</code> instead of <code>c</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[pure]
#[ensures(result &gt;= a &amp;&amp; result &gt;= b)]
#[ensures(result == a || result == b)]
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}

#[ensures(result == max(a, max(b, c)))]
fn max3(a: i32, b: i32, c: i32) -&gt; i32 {
    if a &gt; b &amp;&amp; a &gt; c {
        a
    } else {
        if b &gt; c {
            assert!(max(b, c) == c); // FAILS
            c
        } else {
            c
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When running Prusti on this example, it highlights the failing assertion and thus enables us to quickly locate and fix the issue. </p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Prusti offers a many flags to configure its behavior. See <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/providing.html">Providing Flags</a> for how to provide these flags and <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html">List of Configuration Flags</a> in the developer guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guided-tour"><a class="header" href="#guided-tour">Guided Tour</a></h1>
<blockquote>
<p><strong>Disclaimer:</strong> All code shown in this tutorial has been tested with 
<a href="https://github.com/viperproject/prusti-dev/tree/v-2021-06-11-1413">Prusti v-2021-06-11-14-13</a>.</p>
<p>Unless stated otherwise, all code listings should be put in their own file 
and can be verified with 
<a href="https://marketplace.visualstudio.com/items?itemName=viper-admin.prusti-assistant">Prusti assistant</a>.</p>
</blockquote>
<p>In this chapter, we demonstrate Prusti's capabilities.
As a running example, we roughly follow the first chapters of the Rust tutorial
<a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust with Entirely Too Many Linked Lists</a>.
Linked lists turn out to be sufficiently complex that their implementation and verification
covers most of Rust's and Prusti's essential concepts.
While the above tutorial explains in detail how linked lists are implemented in Rust,
we additionally aim to verify that the implemented list operations are functionally
correct.</p>
<p>While we assume basic familiarity with Rust, it is possible to learn both
Rust and Prusti at the same time by reading this tour and the 
<a href="https://rust-unofficial.github.io/too-many-lists/">Rust tutorial</a>
that inspired it in an interleaved fashion.
We will provide pointers to the Rust tutorial for beginners to catch up where appropriate.</p>
<p>Throughout this tour, we will cover the following Prusti concepts:</p>
<ul>
<li>How Prusti reports errors and integrates into the development process</li>
<li>Runtime errors detected by Prusti</li>
<li>Writing function-modular specifications </li>
<li>Using <em>pure</em> functions in specifications</li>
<li>Writing loop invariants </li>
<li>Using <em>trusted wrappers</em> to deal with library code</li>
<li>Basic troubleshooting</li>
</ul>
<p>The individual chapters are found in the sidebar, which may be collapsed on mobile
devices.
As a quick reference, the main steps of this tour and the involved Prusti features
are as follows:</p>
<ol>
<li><a href="tour/getting-started.html">Getting Started</a>: Simple runtime errors caught by Prusti</li>
<li><a href="tour/new.html">New</a>: Postconditions, pure functions</li>
<li><a href="tour/push.html">Push</a>: Preconditions, trusted functions, old expressions, quantifiers</li>
<li><a href="tour/pop.html">Pop</a>: Exercise with similar concepts as for push</li>
<li><a href="tour/testing.html">Testing</a>: More runtime errors caught by Prusti</li>
<li><a href="tour/bad-stack.html">A Bad Stack</a>: Wrap-up of the second chapter of
<a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust with Entirely Too Many Linked Lists</a>.</li>
<li><a href="tour/options.html">Options</a>: Verification with option types</li>
<li><a href="tour/generics.html">Generics</a>: Prusti and generics</li>
<li><a href="tour/peek.html">Peek</a>: Exercise</li>
<li><a href="tour/final.html">Final Code</a>: Final code with solution of exercise</li>
<li><a href="tour/pledges.html">Pledges</a>: Bonus demonstrating Prusti's pledges</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Our first goal is to implement and verify a simple singly-linked stack that stores
32 bit integers <em>without</em> relying on existing data structures 
provided by Rust's standard library.</p>
<p>For readers that are unfamiliar with Rust, this is a good time to additionally
read the introduction of the accompanying Rust tutorial 
<a href="https://rust-unofficial.github.io/too-many-lists/index.html">Learn Rust With Entirely Too Many Linked Lists</a>,
which explains the Rust features covered by the tutorial and how to set up a 
new project with Cargo.</p>
<p>From now on, we will simply provide links to the relevant parts of the
Rust tutorial together with a brief summary. 
For example, reading up on possible data layouts for lists might be useful for beginners:</p>
<blockquote>
<p><strong>Recommended reading:</strong> 
<a href="https://rust-unofficial.github.io/too-many-lists/first-layout.html">2.1: Basic Data Layout</a></p>
<p>Discusses potential pitfalls and errors when setting up a singly-linked data structure in Rust.</p>
</blockquote>
<h2 id="stack-layout"><a class="header" href="#stack-layout">Stack Layout</a></h2>
<p>Our naïve singly-linked stack is composed of a public structure <code>List</code> storing 
the head of the list, an enum <code>Link</code> representing either an empty list or a heap-allocated
Node storing the payload—an integer—and the link to the next node:</p>
<pre><code class="language-rust noplaypen">pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
// Prusti: VERIFIES
</code></pre>
<p>This design avoid making both <code>Link</code> and <code>Node</code> public.
Moreover, it benefits from the Rust compiler's <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums">null-pointer optimization</a>
and makes sure that all list elements are uniformly allocated on the heap.</p>
<h2 id="absence-of-runtime-errors"><a class="header" href="#absence-of-runtime-errors">Absence of Runtime Errors</a></h2>
<p>Prusti automatically checks that no statement or macro that causes
an explicit runtime error, such as
<a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic</code></a>,
<a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable</code></a>,
<a href="https://doc.rust-lang.org/std/macro.unimplemented.html"><code>unimplemented</code></a>, or
possibly a failing <a href="https://doc.rust-lang.org/std/macro.assert.html">assertion</a>,
is reachable.</p>
<p>For example, the following test function creates a node with no successor and panics
if the node's payload is greater than 23:</p>
<pre><code class="language-rust noplaypen"><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let test = Node {
        elem: 17,
        next: Link::Empty,
    };

    if test.elem &gt; 23 {
        panic!() // unreachable
    }
}
// Prusti: VERIFIES
</code></pre>
<p>Prusti successfully verifies the above function 
because it can statically guarantee that <code>test.elem &lt;= 23</code> holds 
whenever execution reaches the <code>if</code> statement.</p>
<p>This is not the case for the following function in which the test node is initialized
with an arbitrary integer:</p>
<pre><code class="language-rust noplaypen"><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn test(x: i32) {
    let test = Node {
        elem: x, // unknown value
        next: Link::Empty,
    };

    if test.elem &gt; 23 {
        panic!()
    }
}
// Prusti: FAILS
</code></pre>
<p>Prusti reports errors in the same fashion as the Rust compiler (although with the prefix
<code>Prusti: verification error</code>). For example, the error produced for the above function
is:</p>
<pre><code>error: [Prusti: verification error] panic!(..) statement might be reachable
  --&gt; 03-fail.rs:33:9
   |
33 |         panic!()
   |         ^^^^^^^^
   |
   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
Verification failed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new"><a class="header" href="#new">New</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong> 
<a href="https://rust-unofficial.github.io/too-many-lists/first-new.html">2.2: New</a>, 
<a href="https://rust-unofficial.github.io/too-many-lists/first-ownership.html">2.3: Ownership 101</a></p>
<p>How to associate code with a type through <code>impl</code> blocks; 
writing simple static functions;
Rust's ownership system.</p>
</blockquote>
<h2 id="implementing-new"><a class="header" href="#implementing-new">Implementing New</a></h2>
<p>We first provide a static function to create empty lists:</p>
<pre><code class="language-rust noplaypen"><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    // Self is an alias for the type that we are currently implementing
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty,
        }
    }
}
// Prusti: VERIFIES
</code></pre>
<h2 id="a-first-specification"><a class="header" href="#a-first-specification">A First Specification</a></h2>
<p>What would be a sensible first specification for <code>new()</code>?
We could attempt to verify the list returned by <code>new()</code> is always empty.
In other words, the length of the returned list is always zero.
To express this property, we first implement a length method for lists which
itself calls an auxiliary length method implemented for <code>Link</code>.
For simplicity, we will not actually compute the length of a <code>Link</code> yet.
Rather, we will just always return 0.</p>
<pre><code class="language-rust noplaypen">#![feature(box_patterns)] // convenience notation for boxes
<span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }
<span class="boring">
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span>}

impl Link {
    fn len(&amp;self) -&gt; usize {
        0
    }
}
// Prusti: VERIFIES
</code></pre>
<p>Now that we have implemented a method for computing the length of a list, we can
write our first specification for <code>new()</code>: the returned list should always have length
zero.
That is, we attach the <a href="tour/../verify/prepost.html">postcondition</a>
<code>result.len() == 0</code> to the function <code>new()</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">//uncomment: #![feature(box_patterns)]
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty
        }
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       0
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>Unfortunately, Prusti—or rather: the Rust compiler—will complain about
the postcondition:</p>
<pre><code>error: cannot find attribute `ensures` in this scope
  --&gt; list.rs:39:7
   |
39 |     #[ensures(result.len() == 0)]    
   |       ^^^^^^^
</code></pre>
<p>Prusti's specifications consist of Rust
<a href="https://doc.rust-lang.org/reference/procedural-macros.html">macros and attributes</a>
that are defined in a separate crate called <code>prusti_contracts</code>.
Before we can use these specifications, we need to make the path to these
macros and attributes visible:</p>
<pre><code class="language-rust noplaypen"><span class="boring">//uncomment: #![feature(box_patterns)]
</span>use prusti_contracts::*; 

<span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty
        }
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       0
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>Declaring that we use the <code>prusti_contracts</code> crate removes the compiler error but
leads to a new error. This time it is an error raised by Prusti:</p>
<pre><code>error: [Prusti: invalid specification] use of impure function &quot;List::len&quot; in pure code is not allowed
  --&gt; list.rs:34:15
   |
34 |     #[ensures(result.len() == 0)]    
   | 
</code></pre>
<p>Prusti complains about our use of the method <code>len()</code> in a postcondition because the
<a href="tour/../syntax.html">specification syntax</a> only admits calling so-called
<a href="tour/../verify/pure.html">pure functions</a>, that is, functions that are deterministic,
have no side effects, and always terminate.</p>
<p>While our implementation of <code>len()</code> clearly satisfies all of the above properties,
Prusti requires us to explicitly mark a function with the <code>#[pure]</code> attribute
before it considers a function pure.
After adding the <code>#[pure]</code> attribute to our <code>List::len()</code> method, it is allowed to
appear in Prusti specifications:</p>
<pre><code class="language-rust noplaypen"><span class="boring">//uncomment: #![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*; 
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }
<span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       0
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>However, Prusti still won't verify! It produces the same error but now it refers
to the <em>body</em> of <code>len()</code>:</p>
<pre><code>error: [Prusti: invalid specification] use of impure function &quot;Link::len&quot; in pure code is not allowed
  --&gt; list.rs:30:9
   |
30 |         self.head.len() // (5)
   |         ^^^^
</code></pre>
<p>Whenever we add the attribute <code>#[pure]</code> to a function, Prusti will check whether that
function is indeed deterministic and side-effect free
(notice that termination is <em>not</em> checked); otherwise, it complains.
In this case, Prusti complains because we call an impure function,
namely <code>Link::len()</code>, within the body of the pure function <code>List::len()</code>.</p>
<p>To fix this issue, it suffices to mark <code>Link::len()</code> as pure as well.</p>
<pre><code class="language-rust noplaypen"><span class="boring">//uncomment: #![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*; 
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>impl Link {
    #[pure]
    fn len(&amp;self) -&gt; usize {
        0
    }
}
<span class="boring">
</span><span class="boring">fn main() {} // in case Prusti is used via command line
</span><span class="boring">
</span>// Prusti: VERIFIES
</code></pre>
<pre><code>$ prusti-rustc list.rs
// ...
Successful verification of 4 items
</code></pre>
<p>Prusti now manages to verify that <code>new()</code> always returns
a list for which the method <code>len()</code> returns 0. (notice
this is hardly surprising since <code>len()</code> ultimately always returns 0 but we will change
this soon.)</p>
<h2 id="full-code-listing"><a class="header" href="#full-code-listing">Full code listing</a></h2>
<p>Before we continue, we provide the full code implented in this chapter.
It should successfully verify with Prusti and we will further extend it throughout
the next four chapters.</p>
<pre><code class="language-rust noplaypen">#![feature(box_patterns)]
use prusti_contracts::*;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

impl List {
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }

    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty,
        }
    }
}

impl Link {
    #[pure]
    fn len(&amp;self) -&gt; usize {
        0
    }
}

fn main() {} // in case Prusti is used via command line

// Prusti: VERIFIES
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push"><a class="header" href="#push">Push</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong> 
<a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a></p>
</blockquote>
<h2 id="informal-specifications"><a class="header" href="#informal-specifications">Informal specifications</a></h2>
<p>Our next goal is to implement and verify a method that pushes an integer onto a list.
In contrast to methods like <code>len</code>, <code>push</code> modifies the list; it thus takes
<code>&amp;mut self</code> as its first argument:</p>
<pre><code class="language-rust noplaypen">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
</code></pre>
<p>Before we implement <code>push</code>, let us briefly think of possible specifications.
Ideally, our implementation satisfies at least the following properties:</p>
<ol>
<li>Executing <code>push</code> increases the length of the underlying list by one.</li>
<li>After <code>push(elem)</code> the first element of the list stores the value <code>elem</code>.</li>
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged.</li>
</ol>
<h2 id="first-property"><a class="header" href="#first-property">First property</a></h2>
<p>The first property can easily be expressed as a postcondition that uses the
pure method <code>len</code> introduced in the <a href="tour/new.html">previous chapter</a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>The above postcondition depends on <em>two</em> states, namely the state before and after
execution of <code>self.push(elem)</code>, respectively.
We use an <a href="tour/../syntax.html#old-expressions">old expression</a>
to refer to the state before execution of <code>self.push(elem)</code>.
Since we have not implemented <code>push</code> yet, Prusti will, unsurprisingly, complain:</p>
<pre><code>[Prusti: verification error] postcondition might not hold.
</code></pre>
<h2 id="implementing-push"><a class="header" href="#implementing-push">Implementing Push</a></h2>
<p>Conceptually, implementing <code>list.push(i)</code> should be straightforward:
we create a new instance of our struct for list nodes that stores
<code>i</code> in its <code>elem</code> field and the original list in its <code>next</code> field.
We may thus be tempted to write the following:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: self.head,
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>Unfortunately, the Rust compiler will complain about this attempt:</p>
<pre><code>[E0507] cannot move out of `self.head` which is behind a mutable reference.
</code></pre>
<p><code>self</code> is a mutable borrow, meaning once it expires ownership to the referenced data
returns to the original owner.
However, we moved parts of those, the original list, into our newly created node.
This would leave the borrow in a partially initialized state when it expires and would
not allow us to return ownership.
Hence, the compiler raises an error.
See <a href="https://rust-unofficial.github.io/too-many-lists/first-ownership.html">2.3: Ownership 101</a>
and <a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a>
in the Rust tutorial for details. </p>
<p>A working alternative exploits that <code>self</code> is a <em>mutable</em> borrow which allows
us to completely overwrite the referenced data.
Instead of moving the original list into the new node, we <em>swap</em> it 
with an empty list that can be returned to the owner once the borrow expires.
The <a href="https://doc.rust-lang.org/std/mem/fn.replace.html">Rust standard library</a>
provides the function <code>std::mem::replace</code> for that purpose - it moves its second
argument into the referenced first argument and returns the originally referenced value.
Using this function, the Rust compiler accepts the following implementation:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>use std::mem;

<span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre>
<p>In fact, the above implementation of <code>push</code> is correct.
However, attempting to verify it with Prusti still yields a verification error:</p>
<pre><code>[Prusti: verification error] postcondition might not hold.
</code></pre>
<p>This error may look surprising at first: 
We create a new list node that stores the the original list in its next field.
Why is Prusti unable to realize that the length of the resulting list
is one plus the length of the original list?</p>
<p>The explanation is that Prusti performs <em>function modular</em> verification, 
that is, it only uses a function's specification (instead of also consulting the 
function's implementation) whenever it encounters a function call.
The only exception are <em>pure</em> functions, such as <code>len</code>, where Prusti also takes the
function body into account.</p>
<p>In our case, the function <code>std::mem::replace</code> is neither marked as <code>pure</code> nor does it
come with a specification. Hence, Prusti assumes that it is memory safe and nothing else.
That is, Prusti uses <code>true</code> as both pre- and postcondition of <code>std::mem::replace</code>,
which is too weak to prove the specification of <code>push</code>: according to its specification,
<code>std::mem::replace</code> could arbitrarily change the original list and thus also its length.
Hence, we cannot conclude that the length the list returned by
<code>mem::replace(&amp;mut self.head, Link::Empty)</code> coincides with the length of the original 
list.</p>
<p>We can remedy this issue by strengthening the specification of <code>std::mem::replace</code>.
In this tutorial, we will assume that the standard library is correct, that is, we 
do not attempt to verify specifications for functions in external crates, 
like <code>std::mem::replace</code>.
To this end, we introduce a <a href="tour/../verify/trusted.html">trusted</a> wrapper function <code>replace</code>
that calls <code>std::mem::replace</code> and is equipped with the desired specification.
The attribute <code>#[trusted]</code> tells Prusti to assume the provided specification is correct
without attempting to verify it against a function's body.</p>
<p>After introducing a trusted wrapper that ensures that <code>replace</code> does not change the 
length of the original list, the following implementation verifies:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[trusted]
#[ensures(old(dest.len()) == result.len())]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

impl List {
<span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span>// Prusti: VERIFIES
</code></pre>
<p>Trusted functions are useful for dealing with external code, like <code>std::mem::replace</code>, 
or constructs that are not yet supported by Prusti.
<strong>However, a single incorrect specification of a trusted function can invalidate the
correctness of Prusti as a whole!</strong>
Hence, trusted functions, like unsafe Rust code, need to be treated carefully and 
require external justification.</p>
<p>It is good practice to provide strong preconditions for trusted functions 
to reduce the chance that they are accidentially called with unintended arguments.
In our case, we could additionally require that <code>replace</code> always takes an empty
list as its second argument.
We formalize this precondition by introducing another pure function <code>is_empty</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

<span class="boring">impl List {
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">   pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">       let new_node = Box::new(Node {
</span><span class="boring">           elem: elem,
</span><span class="boring">           next: replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">       });
</span><span class="boring">
</span><span class="boring">       self.head = Link::More(new_node);
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>impl Link {
<span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        match self {
            Link::Empty =&gt; true,
            Link::More(box node) =&gt; false,
        }
    }
}
// Prusti: VERIFIES
</code></pre>
<p>This completes our implementation of <code>push</code> but we still need to verify
the remaining properties of its specification.</p>
<h2 id="second-property"><a class="header" href="#second-property">Second property</a></h2>
<p>Recall that the second property of our specification informally reads as follows:</p>
<blockquote>
<ol start="2">
<li>After <code>push(elem)</code> the first element of the list stores the value <code>elem</code>.</li>
</ol>
</blockquote>
<p>To formally specify the above property, we first introduce another pure function, called 
<code>lookup</code>, that recursively traverses the list and returns its i-th element.
Our second desired property then corresponds to the postcondition 
<code>self.lookup(0) == elem</code>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[trusted]
</span><span class="boring">#[ensures(old(dest.len()) == result.len())]
</span><span class="boring">fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
</span><span class="boring">   mem::replace(dest, src)
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span>    
    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)]
    pub fn push(&amp;mut self, elem: i32) {
        // ...
<span class="boring">       let new_node = Box::new(Node {
</span><span class="boring">           elem: elem,
</span><span class="boring">           next: replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">       });
</span><span class="boring">       self.head = Link::More(new_node);
</span>    }
}

impl Link {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::More(box node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            },
            Link::Empty =&gt; unreachable!(),  
        }
    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span>}
</code></pre>
<p>Consider the <code>match</code> statement in the last function.
The Rust compiler will complain if we attempt to omit the case <code>Link::Empty</code>.
Since there is no sensible implementation of <code>lookup</code> if the underlying list is empty,
we used the macro <code>unreachable!()</code>, which will crash the program with a panic.
Since nothing prevents us from calling <code>lookup</code> on an empty list, Prusti complains:</p>
<pre><code>unreachable!(..) statement in pure function might be reachable
</code></pre>
<p>We can specify that <code>lookup</code> should only be called on non-empty lists by adding the 
precondition <code>0 &lt;= index &amp;&amp; index &lt; self.len()</code> to <em>both</em> <code>lookup</code> functions; this is 
sufficient to verify our second property for <code>push</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[trusted]
</span><span class="boring">#[ensures(old(dest.len()) == result.len())]
</span><span class="boring">fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
</span><span class="boring">   mem::replace(dest, src)
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">   pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">       let new_node = Box::new(Node {
</span><span class="boring">           elem: elem,
</span><span class="boring">           next: replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">       });
</span><span class="boring">       self.head = Link::More(new_node);
</span><span class="boring">   }
</span>}

impl Link {
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        // ...
<span class="boring">       match self {
</span><span class="boring">           Link::More(box node) =&gt; {
</span><span class="boring">               if index == 0 {
</span><span class="boring">                   node.elem
</span><span class="boring">               } else {
</span><span class="boring">                   node.next.lookup(index - 1)
</span><span class="boring">               }
</span><span class="boring">           },
</span><span class="boring">           Link::Empty =&gt; unreachable!(),
</span><span class="boring">       }
</span>    }
<span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span>}
// Prusti: VERIFIES
</code></pre>
<h2 id="third-property"><a class="header" href="#third-property">Third property</a></h2>
<p>The third and final property we will verify for <code>push</code> is that the original list
content is not modified:</p>
<blockquote>
<ol start="3">
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged.</li>
</ol>
</blockquote>
<p>To formalize the above property, we can reuse our pure function <code>lookup</code>, 
<a href="tour/../syntax.html#quantifiers">quantifiers</a>, and <a href="tour/../syntax.html#old-expressions">old expressions</a>, that is, we add
the postcondition:</p>
<pre><code class="language-rust noplaypen">#[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
             old(self.lookup(i - 1)) == self.lookup(i)))] 
pub fn push(&amp;mut self, elem: i32) {
    // ...
}
</code></pre>
<p>After adding the above postcondition, Prusti will complain that the postcondition
might not hold; the reason is similar to an issue we encountered when verifying
the first property: the specification of <code>replace</code> is too weak.
Verification succeeds after adding the same postcondition to <code>replace</code>.
We conclude this section with the full code for verifying <code>push</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![feature(box_patterns)]
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">   head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">   Empty,
</span><span class="boring">   More(Box&lt;Node&gt;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">   elem: i32,
</span><span class="boring">   next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
#[ensures(forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; result.len()) ==&gt;
                old(dest.lookup(i)) == result.lookup(i)))]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

impl List {
<span class="boring">   #[pure]
</span><span class="boring">   #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
</span><span class="boring">   pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">       self.head.lookup(index)
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">       self.head.len()
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[ensures(result.len() == 0)]
</span><span class="boring">   pub fn new() -&gt; Self {
</span><span class="boring">       List {
</span><span class="boring">           head: Link::Empty,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span>    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)]
    #[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
                old(self.lookup(i-1)) == self.lookup(i)))]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">   #[pure]
</span><span class="boring">   #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
</span><span class="boring">   pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; unreachable!(),
</span><span class="boring">           Link::More(box node) =&gt; {
</span><span class="boring">               if index == 0 {
</span><span class="boring">                   node.elem
</span><span class="boring">               } else {
</span><span class="boring">                   node.next.lookup(index - 1)
</span><span class="boring">               }
</span><span class="boring">           },
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   #[ensures(!self.is_empty() ==&gt; result &gt; 0)]
</span><span class="boring">   #[ensures(result &gt;= 0)]
</span><span class="boring">   fn len(&amp;self) -&gt; usize {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; 0,
</span><span class="boring">           Link::More(box node) =&gt; 1 + node.next.len(),
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   #[pure]
</span><span class="boring">   fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">       match self {
</span><span class="boring">           Link::Empty =&gt; true,
</span><span class="boring">           Link::More(box node) =&gt; false,
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span>// Prusti: VERIFIES
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop"><a class="header" href="#pop">Pop</a></h1>
<p><strong>TODO</strong></p>
<pre><code class="language-rust noplaypen">/*
    Chapter 2.5 Pop

    Like push, pop wants to mutate the list. 
    Unlike push, we actually want to return something. 
    But pop also has to deal with a tricky corner case: what if the list is empty?
    To represent this case, we introduce an Option type.
    (Option is actually in the standard library but we write our own to assign specs to functions)
*/

#![feature(box_patterns)]
use prusti_contracts::*;

use std::mem;

// (1) alternative would be to introduce trusted functions again...
pub enum TrustedOption {
    Some(i32),
    None,
}

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
#[ensures(forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; result.len()) ==&gt; 
                old(dest.lookup(i)) == result.lookup(i)))] 
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}


impl List {

    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }

    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty,
        }
    }

    #[ensures(self.len() == old(self.len()) + 1)] 
    #[ensures(self.lookup(0) == elem)]
    #[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
        old(self.lookup(i-1)) == self.lookup(i)))]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    // (6) TODO: What would be sensible specifications for pop()?
    // (2): introduce function below
    pub fn pop(&amp;mut self) -&gt; TrustedOption {
        // match self.head { // (2) move out of borrow
        //match &amp;self.head { // (3) use shared reborrow
        match replace(&amp;mut self.head, Link::Empty) { // (5)
            Link::Empty =&gt; {
                TrustedOption::None // (4)
            }
            Link::More(node) =&gt; {
                self.head = node.next; // (4) cannot assign, we just borrowed self.head!
                TrustedOption::Some(node.elem) // (4)
            }
        }
        // unimplemented!() // (2), remove at (4)
    }
}

impl Link {

    #[pure]
    #[ensures(!self.is_empty() ==&gt; result &gt; 0)]
    #[ensures(result &gt;= 0)]
    fn len(&amp;self) -&gt; usize {
        match self {
            Link::Empty =&gt; 0,
            Link::More(box node) =&gt; 1 + node.next.len(),
        }
    }

    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        match self {
            Link::Empty =&gt; true,
            Link::More(box node) =&gt; false,
        }
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::Empty =&gt; unreachable!(),
            Link::More(box node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            }
        }
    }

}
</code></pre>
<pre><code class="language-rust noplaypen">#![feature(box_patterns)]
use prusti_contracts::*;

use std::mem;

pub enum TrustedOption {
    Some(i32),
    None,
}

// (3) add implementation for TrustedOption
impl TrustedOption {

    #[pure]
    pub fn is_none(&amp;self) -&gt; bool {
        match self {
            TrustedOption::Some(_) =&gt; false,
            TrustedOption::None =&gt; true,
        }
    }

    #[pure]
    pub fn is_some(&amp;self) -&gt; bool {
        !self.is_none()
    }

    // (6) add method
    #[pure]
    #[requires(self.is_some())] // (7)
    pub fn peek(&amp;self) -&gt; i32 {
        match self {
            TrustedOption::Some(val) =&gt; *val,
            TrustedOption::None =&gt; unreachable!(),
        }
    }

}

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
#[ensures(forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; result.len()) ==&gt; 
                old(dest.lookup(i)) == result.lookup(i)))] 
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}


impl List {

    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }

    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty,
        }
    }

    #[ensures(self.len() == old(self.len()) + 1)] 
    #[ensures(self.lookup(0) == elem)]
    #[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
        old(self.lookup(i-1)) == self.lookup(i)))]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    // (1) TODO: What would be sensible specifications for pop()?
    //      a) empty list means we return None
    //      b) non-empty list means we return Some(_)
    //      c) lengths are changed correctly
    //      d) the returned value is the first element of the old list
    //      e) all elements except the first one remain unchanged

    // (2) spec a/b) we could add explicit matches but that would be silly
    #[ensures(old(self.len()) == 0 ==&gt; result.is_none())] // (2) spec a)

    #[ensures(old(self.len()) &gt; 0 ==&gt; result.is_some())]  // (2) spec b)
    // (4) specification c)
    #[ensures(old(self.len()) == 0 ==&gt; self.len() == 0)]  // (4) empty lists remain empty
    #[ensures(old(self.len()) &gt; 0 ==&gt; self.len() == old(self.len()-1))] // (4) non-empty lists are 1 smaller
    // (5) specification d)
    #[ensures(old(self.len()) &gt; 0 ==&gt; result.peek() == old(self.lookup(0)))] // (5)
    // (6) specification e)
    #[ensures(old(self.len()) &gt; 0 ==&gt; // (6)
    forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt; // (6)
        old(self.lookup(i+1)) == self.lookup(i)))] // (6)
    pub fn pop(&amp;mut self) -&gt; TrustedOption {
        match replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; {
                TrustedOption::None
            }
            Link::More(node) =&gt; {
                self.head = node.next;
                TrustedOption::Some(node.elem)
            }
        }
    }
}

impl Link {

    #[pure]
    #[ensures(!self.is_empty() ==&gt; result &gt; 0)]
    #[ensures(result &gt;= 0)]
    fn len(&amp;self) -&gt; usize {
        match self {
            Link::Empty =&gt; 0,
            Link::More(box node) =&gt; 1 + node.next.len(),
        }
    }

    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        match self {
            Link::Empty =&gt; true,
            Link::More(box node) =&gt; false,
        }
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::Empty =&gt; unreachable!(),
            Link::More(box node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            }
        }
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p><strong>TODO</strong></p>
<pre><code class="language-rust noplaypen">/*
    Chapter 2.6 - Testing
    Alright, so we've got push and pop written, now we can actually test out our stack! 
    Rust and cargo support testing as a first-class feature, 
    so this will be super easy. 
    All we have to do is write a function, and annotate it with #[test].
*/

#![feature(box_patterns)]
use prusti_contracts::*;

use std::mem;

pub enum TrustedOption {
    Some(i32),
    None,
}

impl TrustedOption {

    #[pure]
    pub fn is_none(&amp;self) -&gt; bool {
        match self {
            TrustedOption::Some(_) =&gt; false,
            TrustedOption::None =&gt; true,
        }
    }

    #[pure]
    pub fn is_some(&amp;self) -&gt; bool {
        !self.is_none()
    }

    #[pure]
    #[requires(self.is_some())]
    pub fn peek(&amp;self) -&gt; i32 {
        match self {
            TrustedOption::Some(val) =&gt; *val,
            TrustedOption::None =&gt; unreachable!(),
        }
    }

}

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}

#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
#[ensures(forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; result.len()) ==&gt; 
                old(dest.lookup(i)) == result.lookup(i)))] 
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}


impl List {

    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }

    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty
        }
    }

    #[ensures(self.len() == old(self.len()) + 1)] 
    #[ensures(self.lookup(0) == elem)]
    #[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
        old(self.lookup(i-1)) == self.lookup(i)))]
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }

    #[ensures(old(self.len()) == 0 ==&gt; result.is_none())]
    #[ensures(old(self.len()) &gt; 0 ==&gt; result.is_some())]
    #[ensures(old(self.len()) == 0 ==&gt; self.len() == 0)]
    #[ensures(old(self.len()) &gt; 0 ==&gt; self.len() == old(self.len()-1))]
    #[ensures(old(self.len()) &gt; 0 ==&gt; result.peek() == old(self.lookup(0)))]
    #[ensures(old(self.len()) &gt; 0 ==&gt;
    forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
        old(self.lookup(i+1)) == self.lookup(i)))]
    pub fn pop(&amp;mut self) -&gt; TrustedOption {
        match replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; {
                TrustedOption::None
            }
            Link::More(node) =&gt; {
                self.head = node.next;
                TrustedOption::Some(node.elem)
            }
        }
    }
}

impl Link {

    #[pure]
    #[ensures(!self.is_empty() ==&gt; result &gt; 0)]
    #[ensures(result &gt;= 0)]
    fn len(&amp;self) -&gt; usize {
        match self {
            Link::Empty =&gt; 0,
            Link::More(box node) =&gt; 1 + node.next.len(),
        }
    }

    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        match self {
            Link::Empty =&gt; true,
            Link::More(box node) =&gt; false,
        }
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::Empty =&gt; unreachable!(),
            Link::More(box node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            }
        }
    }

}


// (1)
pub mod test {
    use super::{List, TrustedOption};

    pub fn basics() {
        let mut list = List::new();

        // (1) Check empty list behaves right
        assert!(list.pop().is_none());

        // (2) Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // (2) Check normal removal
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 3),
            _ =&gt; unreachable!(),
        }
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 2),
            _ =&gt; unreachable!(),
        }

        // (3) Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // (3) Check normal removal
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 5),
            _ =&gt; unreachable!(),
        }
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 4),
            _ =&gt; unreachable!(),
        }

        // (4) Check exhaustion
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 1),
            _ =&gt; unreachable!(),
        }
        assert!(list.pop().is_none());
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-bad-singly-linked-stack---full-code"><a class="header" href="#a-bad-singly-linked-stack---full-code">A Bad Singly-Linked Stack - Full Code</a></h1>
<p><strong>TODO</strong></p>
<pre><code class="language-rust noplaypen">#![feature(box_patterns)] // convenience box syntax

//! An adaptation of the example from
//! https://rust-unofficial.github.io/too-many-lists/first-final.html
//!
//! Proven properties:
//! +   Absence of panics.
//! +   Push and pop behaves correctly.

use prusti_contracts::*;
use std::mem;

pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

impl Link {
    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        match self {
            Link::Empty =&gt; true,
            Link::More(box node) =&gt; false,
        }
    }
    #[pure]
    #[ensures(!self.is_empty() ==&gt; result &gt; 0)]
    #[ensures(result &gt;= 0)]
    fn len(&amp;self) -&gt; usize {
        match self {
            Link::Empty =&gt; 0,
            Link::More(box node) =&gt; 1 + node.next.len(),
        }
    }
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::Empty =&gt; unreachable!(),
            Link::More(box node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            }
        }
    }
}

struct Node {
    elem: i32,
    next: Link,
}

pub enum TrustedOption {
    Some(i32),
    None,
}

impl TrustedOption {
    #[pure]
    pub fn is_none(&amp;self) -&gt; bool {
        match self {
            TrustedOption::Some(_) =&gt; false,
            TrustedOption::None =&gt; true,
        }
    }
    #[pure]
    pub fn is_some(&amp;self) -&gt; bool {
        match self {
            TrustedOption::Some(_) =&gt; true,
            TrustedOption::None =&gt; false,
        }
    }
    #[pure]
    #[requires(self.is_some())]
    pub fn peek(&amp;self) -&gt; i32 {
        match self {
            TrustedOption::Some(val) =&gt; *val,
            TrustedOption::None =&gt; unreachable!(),
        }
    }
}

#[trusted]
#[requires(src.is_empty())]
#[ensures(dest.is_empty())]
#[ensures(old(dest.len()) == result.len())]
#[ensures(forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; result.len()) ==&gt;
                old(dest.lookup(i)) == result.lookup(i)))]
fn replace(dest: &amp;mut Link, src: Link) -&gt; Link {
    mem::replace(dest, src)
}

impl List {

    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }

    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }

    #[ensures(result.len() == 0)]
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty,
        }
    }

    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)]
    #[ensures(forall(|i: usize| (1 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
                    old(self.lookup(i-1)) == self.lookup(i)))]
    pub fn push(&amp;mut self, elem: i32) {
        let old_len = self.head.len();
        let new_node = Box::new(Node {
            elem: elem,
            next: replace(&amp;mut self.head, Link::Empty),
        });
        self.head = Link::More(new_node);
    }

    #[ensures(old(self.len()) == 0 ==&gt; result.is_none())]
    #[ensures(old(self.len()) == 0 ==&gt; self.len() == 0)]
    #[ensures(old(self.len()) &gt; 0 ==&gt; result.is_some())]
    #[ensures(old(self.len()) &gt; 0 ==&gt; result.peek() == old(self.lookup(0)))]
    #[ensures(old(self.len()) &gt; 0 ==&gt; self.len() == old(self.len()-1))]
    #[ensures(old(self.len()) &gt; 0 ==&gt;
                forall(|i: usize| (0 &lt;= i &amp;&amp; i &lt; self.len()) ==&gt;
                    old(self.lookup(i+1)) == self.lookup(i)))]
    pub fn pop(&amp;mut self) -&gt; TrustedOption {
        match replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; {
                TrustedOption::None
            }
            Link::More(node) =&gt; {
                self.head = node.next;
                TrustedOption::Some(node.elem)
            }
        }
    }
}

// added in chapter 2.7
impl Drop for List {
    fn drop(&amp;mut self) {
        let mut cur_link = replace(&amp;mut self.head, Link::Empty);

        let mut continue_loop = true;
        while continue_loop {
            if let Link::More(mut boxed_node) = cur_link {
                cur_link = replace(&amp;mut boxed_node.next, Link::Empty);
            } else {
                continue_loop = false;
            }
        }

    }
}

pub mod test {
    use super::{List, TrustedOption};

    pub fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert!(list.pop().is_none());

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 3),
            _ =&gt; unreachable!(),
        }
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 2),
            _ =&gt; unreachable!(),
        }

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 5),
            _ =&gt; unreachable!(),
        }
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 4),
            _ =&gt; unreachable!(),
        }

        // Check exhaustion
        match list.pop() {
            TrustedOption::Some(val) =&gt; assert!(val == 1),
            _ =&gt; unreachable!(),
        }
        assert!(list.pop().is_none());
    }
}

fn main() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="peek"><a class="header" href="#peek">Peek</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-list-code"><a class="header" href="#final-list-code">Final List Code</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pledges"><a class="header" href="#pledges">Pledges</a></h1>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-features"><a class="header" href="#verification-features">Verification Features</a></h1>
<p>Even if no specifications are provided, Prusti is capable of verifying a few basic properties about the supplied Rust code.
These properties include:</p>
<ul>
<li><a href="verify/panic.html">Absence of panics</a></li>
<li><a href="verify/overflow.html">Overflow checks</a></li>
</ul>
<p>More intricate properties require users to write suitable <a href="verify/syntax.html">specifications</a>.
The following features are either currently supported or planned to be supported in Prusti:</p>
<ul>
<li><a href="verify/prepost.html">Pre- and postconditions</a></li>
<li><a href="verify/assert_assume.html">Assertions and assumptions</a></li>
<li><a href="verify/trusted.html">Trusted functions</a></li>
<li><a href="verify/pure.html">Pure functions</a></li>
<li><a href="verify/predicate.html">Predicates</a></li>
<li><a href="verify/external.html">External specifications</a></li>
<li><a href="verify/loop.html">Loop body invariants</a></li>
<li><a href="verify/pledge.html">Pledges</a></li>
<li><a href="verify/traits.html">Trait contract refinement</a></li>
<li><a href="verify/closure.html">Closures</a></li>
<li><a href="verify/spec_ent.html">Specification entailments</a></li>
<li><a href="verify/type-models.html">Type models</a></li>
</ul>
<p>By default, Prusti only checks absence of panics.
Moreover, Prusti verifies <em>partial</em> correctness. That is, it only verifies that <em>terminating</em> program executions meet the supplied specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="absence-of-panics"><a class="header" href="#absence-of-panics">Absence of panics</a></h1>
<p>With the default settings, Prusti checks absence of panics. For example, consider the following program which always panics when executed:</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    unreachable!();
}
</code></pre></pre>
<p>When run on the previous program, Prusti reports a verification error:</p>
<pre><code class="language-plain">error[P0004]: unreachable!(..) statement might be reachable
 --&gt; src/lib.rs:2:5
  |
2 |     unreachable!();
  |     ^^^^^^^^^^^^^^^
  |
</code></pre>
<p>This message correctly points out that the <code>unreachable!()</code> statement might actually be reachable.</p>
<p>The message says &quot;might&quot; because Prusti is conservative, i.e., it reports a verification error <em>unless</em> it can prove that the statement is unreachable.
Hence, Prusti successfully the example below as it can rule out that the condition in the conditional statement, <code>a &lt;= 0</code>, holds.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    let a = 5;
    if a &lt;= 0 {
        unreachable!();
    }
}
</code></pre></pre>
<p>Since Prusti is conservative, if it reports no verification errors then the program is provably correct <em>with regard to the checked properties.</em>
The last part is important because checks such as <a href="verify/overflow.html">overflow checks</a> may be disabled. 
Furthermore, Prusti may verify a program although some (or even all) of its executions do not terminate because it verifies partial correctness properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflow-checks"><a class="header" href="#overflow-checks">Overflow checks</a></h1>
<p>Overflow checks are enabled by default.</p>
<p>When overflow checks are enabled, Prusti models integers as bounded values with a range that depends on the type of the integer. Values of <code>u32</code> types, for example, would be modeled to be between <code>0</code> and <code>2^32 - 1</code>.</p>
<p>When overflow checks are disabled, Prusti models each integer type as an unbounded integer.</p>
<p>Overflow checks can be disabled by setting the <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#check_overflows"><code>check_overflows</code></a> flag to <code>false</code>. See <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/providing.html">Providing Flags</a> in the developer guide for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre--and-postconditions"><a class="header" href="#pre--and-postconditions">Pre- and postconditions</a></h1>
<p>In Prusti, the externally observable behaviour of a function can be specified with preconditions and postconditions. They can be provided using <a href="https://doc.rust-lang.org/reference/attributes.html">Rust attributes</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[requires(...)]
#[ensures(...)]
fn example() { ... }
<span class="boring">}
</span></code></pre></pre>
<p><code>#[requires(...)]</code> is a precondition, <code>#[ensures(...)]</code> is a postcondition. There can be any number (including none) of preconditions and postconditions attached to a function. When no precondition is specified, <code>#[requires(true)]</code> is assumed, and likewise for postconditions. The expression inside the parentheses of <code>requires</code> or <code>ensures</code> should be a <a href="verify/../syntax.html">Prusti specification</a>.</p>
<p>Preconditions are checked whenever the given function is called. Postconditions are checked at any exit point of the function, i.e. explicit <code>return</code> statements, as well as the end of the function body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions-and-assumptions"><a class="header" href="#assertions-and-assumptions">Assertions and Assumptions</a></h1>
<p>You can use Prusti to verify that a certain property holds at a certain point
within the body of a function (via an assertion). It is also possible to
instruct Prusti to assume that a property holds at a certain point within a
function (via an assumption).</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>The <code>prusti_assert!</code> macro instructs Prusti to verify that a certain property
holds at a specific point within the body of a function. In contrast to the
<code>assert!</code> macro, which only accepts Rust expressions, <code>prusti_assert!</code> accepts
<a href="verify/../syntax.html">specification</a> expressions as arguments. Therefore, quantifiers
and <code>old</code> expressions are allowed within a call to <code>prusti_assert!</code>, as in
the following example:</p>
<pre><code class="language-rust noplaypen">#[requires(*x != 2)]
fn go(x: &amp;mut u32) {
   *x = 2;
   prusti_assert!(*x != old(*x));
}
</code></pre>
<p>Note that the expression given to <code>prusti_assert!</code> must be side-effect free.
Therefore, certain calls might work within an <code>assert!</code>, but not within a
<code>prusti_assert!</code>. For example:</p>
<pre><code class="language-rust noplaypen">assert!(map.insert(5));
prusti_assert!(map.insert(5)); // error
</code></pre>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>The <code>prusti_assume!</code> macro instructs Prusti to assume that a certain property
holds at a point within the body of a function. Of course, if used improperly,
this can be used to introduce unsoundness. For example, Prusti would verify the
following function:</p>
<pre><code class="language-rust noplaypen">#[ensures(p == np)]
fn proof(p: u32, np: u32) {
  prusti_assume!(false);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-functions"><a class="header" href="#trusted-functions">Trusted functions</a></h1>
<p>Sometimes specifications express a fact which is true about a function, but the verifier cannot prove it automatically, or it uses features not yet supported by Prusti. In such cases, it is possible to mark a function as <code>#[trusted]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[trusted]
#[ensures(*a == old(*b) &amp;&amp; *b == old(*a))]
fn xor_swap(a: &amp;mut i32, b: &amp;mut i32) {
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, the contract for <code>xor_swap</code> is correct, but Prusti would not be able to verify it because it uses currently unsupported XOR operations.</p>
<p>While a common application of <code>#[trusted]</code> is to wrap functions from the standard library or external libraries, notice that <a href="verify/external.html">external specifications</a> provide a more robust solution for this use case.</p>
<h2 id="why-trusted-functions-are-dangerous"><a class="header" href="#why-trusted-functions-are-dangerous">Why trusted functions are dangerous</a></h2>
<p>When declaring a function as <code>#[trusted]</code>, Prusti ignores the function's body and assumes the provided pre- and postconditions have already been successfully verified.
As the example below demonstrates, a single wrong, yet trusted, specification may lead to wrong and unexpected verification results.
Hence, some care is needed to ensure that the specifications of trusted functions are indeed correct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[trusted]
#[ensures(42 == 23)] // assumed correct since we trust foo()
fn foo() { unreachable!() }

fn test() {
    foo();
    assert!(1 == 2); // verifies successfully
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pure-functions"><a class="header" href="#pure-functions">Pure functions</a></h1>
<p>Pure functions are functions which are deterministic and side-effect free. In Prusti, such functions can be marked with the <code>#[pure]</code> attribute. They can take shared references as arguments, but they cannot take mutable references, because modifying the heap is considered a side effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[pure]
#[ensures(result == *a + *b)]
fn pure_example(a: &amp;i32, b: &amp;i32) -&gt; i32 {
  *a + *b
}

#[ensures(*c == a + b)]
fn impure_example(a: &amp;i32, b: &amp;i32, c: &amp;mut i32) {
  *c = *a + *b
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>Predicates are similar to <a href="verify/pure.html">pure functions</a> in that they are deterministic and side-effect free and used in specifications.</p>
<p>They are more powerful than pure functions: inside predicate bodies the full <a href="verify/../syntax.html">Prusti specification syntax</a> is allowed. However, they are not usable in regular Rust code, as there are no direct Rust equivalents for specification constructs like <a href="verify/../syntax.html#quantifiers">quantifiers</a> or <a href="verify/../syntax.html#implications">implications</a>. Instead, predicates can only be called from within specifications.</p>
<p>Predicates are declared using the <code>predicate!</code> macro on a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>predicate! {
    fn all_zeroes(a: &amp;MyArray) -&gt; bool {
        forall(|i: usize|
            (0 &lt;= i &amp;&amp; i &lt; a.len() ==&gt; a.lookup(i) == 0))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Within specifications, predicates can be called just like pure functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ensures(all_zeros(a))]
fn zero(a: &amp;mut MyArray) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>The <code>predicate!</code> macro is incompatible with other Prusti specifications, i.e. a predicate function cannot have pre- or postconditions. The body of a predicate must be provided, so it cannot be <a href="verify/trusted.html"><code>#[trusted]</code></a>. Predicates are always considered pure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-specifications"><a class="header" href="#external-specifications">External specifications</a></h1>
<p>Since the Rust standard library and external libraries do not specify contracts for their functions, Prusti allows specifying the contract for functions separately from where they are implemented. Such a specification looks like a regular <code>impl</code>, with the exception that there are no bodies in the implementation functions, and that the <code>impl</code> has an <code>#[extern_spec]</code> attribute.</p>
<p>The standard library type <code>std::option::Option</code> could be specified as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[extern_spec]
impl&lt;T&gt; std::option::Option&lt;T&gt; {
    #[pure]
    #[ensures(matches!(*self, Some(_)) == result)]
    pub fn is_some(&amp;self) -&gt; bool;

    #[pure]
    #[ensures(self.is_some() == !result)]
    pub fn is_none(&amp;self) -&gt; bool;

    #[requires(self.is_some())]
    pub fn unwrap(self) -&gt; T;

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Any function in an external specification is implicitly <a href="verify/trusted.html">trusted</a> (as if marked with <code>#[trusted]</code>). It is possible to specify multiple <code>#[extern_spec]</code> implementations for the same type, but it is an error to externally specify the same function multiple times.</p>
<p>Module functions can be specified using a nested <code>mod</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[extern_spec]
mod std {
    mod mem {
        use prusti_contracts::*;

        #[ensures(*a == old(*b) &amp;&amp; *b == old(*a))]
        pub fn swap(a: &amp;mut i32, b: &amp;mut i32);
        // pub fn swap&lt;T: std::cmp::PartialEq + Copy&gt;(a: &amp;mut T, b: &amp;mut T);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are currently issues with external specifications combined with generics, so the function <code>swap</code> above is specified for <code>i32</code> arguments only.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-body-invariants"><a class="header" href="#loop-body-invariants">Loop body invariants</a></h1>
<p>To verify loops, including loops in which the loop condition has side effects, Prusti allows specifying the <em>invariant of the loop body</em> using the <code>body_invariant!(...);</code> statement. The expression inside the parentheses should be a <a href="verify/../syntax.html">Prusti specification</a>. There may be any number of body invariants in any given loop, but they must all be written at the beginning of the loop body.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th></tr></thead><tbody>
<tr><td>Loop conditions without side-effects</td><td>Supported</td></tr>
<tr><td>Loop conditions with side-effects</td><td>Supported</td></tr>
<tr><td>Loops with <code>break</code>, <code>continue</code>, or <code>return</code> statements</td><td>Supported</td></tr>
<tr><td>Loans that cross a loop boundary (e.g. loans defined outside the loop, expiring in the loop)</td><td>Not supported yet</td></tr>
</tbody></table>
</div>
<p>In general, given the loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while {
  G; // possibly side-effectful
  g // loop condition
} {
  body_invariant!(I); // loop body invariant
  B // loop body
}
<span class="boring">}
</span></code></pre></pre>
<p>Prusti checks the following:</p>
<ol>
<li>The first time that <code>G</code> has been executed, if <code>g</code> evaluates to <code>true</code> then the property <code>I</code> must hold.</li>
<li>Assuming that the property <code>I</code> holds, after executing <code>B; G</code>, if <code>g</code> evaluates to <code>true</code> then <code>I</code> must hold (again).</li>
</ol>
<p>After the loop, Prusti knows that the program is in a state in which the loop condition evaluated to <code>false</code>. This can happen for two reasons:</p>
<ol>
<li>The loop body has never been executed, because the first evaluation of the loop condition resulted in <code>false</code>. In this case, the invariant in the loop body is never reached.</li>
<li>The loop executed at least one iteration, then after executing <code>B</code> the evaluation of <code>{ G; g }</code> resulted in <code>false</code>.</li>
</ol>
<p>Finally, the loop body invariant is not enforced when exiting from a loop with a <code>break</code> or <code>return</code> statement.</p>
<p>As an example, consider the following program. The loop condition calls <code>test_and_increment</code>, and the call has side effects:</p>
<pre><pre class="playground"><code class="language-rust">use prusti_contracts::*;

#[ensures(result == (old(*i) &gt;= 0))]
#[ensures(*i == 1 + old(*i))]
fn test_and_increment(i: &amp;mut usize) -&gt; bool {
    let old_i = *i;
    *i += 1;
    old_i &gt;= 0
}

#[requires(*i &gt; 0)]
fn work(i: &amp;mut usize) {
    // ...
}

fn main() {
    let mut i = 0;

    while test_and_increment(&amp;mut i) {
        body_invariant!(i &gt; 0);
        work(i);
    }

    assert!(i &lt;= 0);
}
</code></pre></pre>
<p>We can assert <code>i &lt;= 0</code> after the loop, because in the last evaluation of the loop condition <code>i &gt;= 0</code> was <code>false</code>, and <code>i</code> was then incremented by one.</p>
<p>Note that it would be wrong to assert <code>i &lt; 0</code> after the loop, because it is possible to have <code>i == 0</code>. Note also that the loop body invariant <code>i &gt;= 0</code> is not strong enough to verify the program, since <code>work</code> requires <code>i &gt; 0</code>. In fact, after <code>test_and_increment</code> returns <code>true</code>, <code>i</code> cannot be <code>0</code> because of the <code>+= 1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pledges-1"><a class="header" href="#pledges-1">Pledges</a></h1>
<p>Pledges are a construct that can be used to specify the behaviour of functions that reborrow. For example, pledges should be used for modelling an assignment to a vector element because, in Rust, <code>v[i] = 4</code> is not a method call <code>v.store(i, 4)</code> but rather <code>let tmp = v.get_mut(i); *tmp = 4</code>, where <code>get_mut</code> is a method that reborrows the <code>v</code> receiver to return a reference to a particular element.</p>
<p>As a full example, a wrapper around Rust <code>Vec&lt;i32&gt;</code> could be implemented as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

pub struct VecWrapperI32 {
    v: Vec&lt;i32&gt;
}

impl VecWrapperI32 {
    #[trusted]
    #[pure]
    #[ensures(result &gt;= 0)]
    pub fn len(&amp;self) -&gt; usize {
        self.v.len()
    }

    /// A ghost function for specifying values stored in the vector.
    #[trusted]
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.v[index]
    }

    #[trusted]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    #[ensures(*result == old(self.lookup(index)))]
    #[after_expiry(
        self.len() == old(self.len()) &amp;&amp;
        self.lookup(index) == before_expiry(*result) &amp;&amp;
        forall(
            |i: usize| (0 &lt;= i &amp;&amp; i &lt; self.len() &amp;&amp; i != index) ==&gt;
            self.lookup(i) == old(self.lookup(i))
        )
    )]
    pub fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut i32 {
        self.v.get_mut(index).unwrap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax for a pledge is <code>#[after_expiry&lt;reference&gt;(condition)]</code> where
<code>reference</code> is the reborrowing reference (defaults to <code>result</code>, which is
currently the only thing one can write until we have support for
reference fields) and <code>condition</code> is a <a href="verify/../syntax.html">Prusti specification</a> that specifies how the borrowed data
structure will look once the borrow expires. To refer to the state that
a memory location pointed at by the reference has just before expiring,
use <code>before_expiry(*reference)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-contract-refinement"><a class="header" href="#trait-contract-refinement">Trait contract refinement</a></h1>
<blockquote>
<p><strong>NOT YET SUPPORTED:</strong> This feature is not yet supported in the new version of Prusti.</p>
</blockquote>
<p>In some cases, marker traits simply modify the behavior of methods in their super-traits. For instance consider the <code>PartialEq&lt;T&gt;</code> and <code>Eq</code> traits. In order to consider this additional behavior for verification, traits support contract refinement on trait level:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PartialEq&lt;Rhs: ?Sized = Self&gt; {
    #[ensures(/* partial equivalence formulas */)]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}

#[refine_ensures(PartialEq::eq = &quot;self.eq(&amp;self)&quot;)]
pub trait Eq: PartialEq&lt;Self&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>Thus, any client implementing <code>Eq</code> on a custom type can take advantage of the additional semantics of the total equivalence. Similarly <code>#[refine_requires]</code> can be used to refine the precondition of a super-trait.</p>
<blockquote>
<p>Such trait refinement is not scoped. Therefore, considering the previous example, implementing <code>Eq</code> on a type implies that the total equivalence contract is always considered on the type, irrespective of whether <code>Eq</code> is in scope or not.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<blockquote>
<p><strong>NOT YET SUPPORTED:</strong> This feature is not yet supported in Prusti. See <a href="https://github.com/viperproject/prusti-dev/pull/138">PR #138</a> for the status of this feature as well as a prototype. The syntax described here is subject to change.</p>
</blockquote>
<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Rust closures</a> can be given a specification using the <code>closure!(...)</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust">use prusti_contracts::*;

fn main() {
    let cl = closure!(
        requires(a &gt; b),
        ensures(result &gt; b),
        |a: i32, b: i32| -&gt; i32 { a }
    );
}
</code></pre></pre>
<p><code>closure!</code> can have any number of pre- and postconditions. The arguments and return type for the closure must be given explicitly. See <a href="verify/spec_ent.html">specification entailments</a> for specifying the contract of a higher-order function (e.g. when taking a closure as an argument).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification-entailments"><a class="header" href="#specification-entailments">Specification entailments</a></h1>
<blockquote>
<p><strong>NOT YET SUPPORTED:</strong> This feature is not yet supported in Prusti. See <a href="https://github.com/viperproject/prusti-dev/pull/138">PR #138</a> for the status of this feature as well as a prototype. The syntax described here is subject to change.</p>
</blockquote>
<p>The contract for a closure or function pointer variable can be given using the specification entailment syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[requires(
  f |= |a: i32, b: i32| [
    requires(a == 5),
    requires(b == 4),
    ensures(result &gt; 4)
  ]
)]
fn example&lt;F: Fn (i32, i32) -&gt; i32&gt; (f: F) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, <code>f</code>, the argument to <code>example</code>, must be a function that takes two <code>i32</code> arguments. A call to <code>f</code> inside the body of <code>example</code> is only valid if the preconditions are satisfied, and the result of that call must satisfy the postcondition given.</p>
<blockquote>
<p>TODO:</p>
<ul>
<li>arrow syntax (<code>~~&gt;</code>)</li>
<li>ghost arguments</li>
<li>history invariants</li>
<li>multiple-call specification entailment</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-models"><a class="header" href="#type-models">Type Models</a></h1>
<p>Some structs, mostly non-local structs from other crates, contain non-public code which are essential for verification.
To provide a specification for such structs, you can add model fields to be used in specifications. To introduce a type
model for a struct, simply annotate it with the <code>#[model]</code> macro and declare the to-be-modelled fields inside the
struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[model]
struct SomeStruct {
    some_i32: i32,
    // ... more fields
}
<span class="boring">}
</span></code></pre></pre>
<p>You then can use the model of <code>SomeStruct</code> inside specifications via the <code>.model()</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[requires(some_struct.model().some_i32 == 42)]
fn some_method(some_struct: &amp;SomeStruct) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>A model cannot be used outside of specification code, that is the following code will emit an error in Prusti and panic
when executed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_client(some_struct: &amp;mut SomeStruct) {
    some_struct.model().some_i32 = 42;
}
<span class="boring">}
</span></code></pre></pre>
<p>This means that a model cannot be instantiated or directly manipulated with runtime code. Instead, the <em>source</em> of a
model is always a <a href="verify/trusted.html">trusted function</a> or an <a href="verify/external.html">external specification</a>.</p>
<h2 id="generic-models"><a class="header" href="#generic-models">Generic models</a></h2>
<p>Models can be generic over type parameters or concrete type arguments. That is, given a struct <code>SomeGenericStruct&lt;A, B&gt;</code>
, you can define models for:</p>
<ul>
<li>Concrete type arguments, e.g. <code>SomeGenericStruct&lt;i32, u32&gt;</code> and <code>SomeGenericStruct&lt;u32, usize&gt;</code></li>
<li>Generic type parameters, e.g. <code>SomeGenericStruct&lt;A, B&gt;</code></li>
<li>Mix the two concepts, e.g. <code>SomeGenericStruct&lt;A, i32&gt;</code></li>
</ul>
<p>Different (generic) models for the same type can have different fields. In order to correctly parse the model, Prusti
needs attributes attached to the generics. A type argument needs to be attributed with <code>#[concrete]</code>, a type parameter
with <code>#[generic]</code>. In the last example above, we would create a model with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[model]
struct SomeGenericStruct&lt;#[generic] A: Copy, #[concrete] i32&gt; {
    field_a: A
    // ... fields
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: If you create ambiguous models, you can get a compile error when accessing the model via the <code>.model()</code> method.</p>
<h2 id="further-remarks"><a class="header" href="#further-remarks">Further remarks</a></h2>
<ul>
<li>A model needs to be copyable, i.e. all fields need to be <code>Copy</code>. That also applies to type parameters where you need
to add the <code>Copy</code> trait as a bound.</li>
<li>When the modelled type has no fields, a warning will be emmitted. Using <code>.model()</code> on such types can lead to unsound
verification results. See below for an example.</li>
</ul>
<h3 id="modelled-types-should-have-fields"><a class="header" href="#modelled-types-should-have-fields">Modelled types should have fields</a></h3>
<p>Using models on types without fields can have unexpected verification behavior as shown in the code snippet below:</p>
<pre><pre class="playground"><code class="language-rust">struct A;

// no fields
#[model]
struct A {
    val: i32
}

#[trusted]
#[ensures(result.model().val == with_model_val)]
fn create_a(with_model_val: i32) -&gt; A { A {} }

fn main() {
    let a1 = create_a(42);
    let a2 = create_a(43);
    // Can prove: a1.model().val == x for any x
    // Can prove: a2.model().val == x for any x
}
</code></pre></pre>
<p>The reason for this is due to the encoding of <code>A</code> in Viper. When encoding the <code>main</code> function, Prusti creates two
snapshots for <code>a1</code> and <code>a2</code>. Since <code>A</code> has no fields, any two snapshots of <code>A</code> will be considered equal and thereafter,
their models too. When inhaling the two postconditions for the call to <code>create_a</code> in <code>main</code> Viper thus assumes that the
field <code>val</code> for the <em>same</em> model is <code>42</code> and <code>43</code>, a contradiction.</p>
<h2 id="example-stditeriter"><a class="header" href="#example-stditeriter">Example: <code>std::iter::Iter</code></a></h2>
<blockquote>
<p><strong>Caution</strong></p>
<p>As of yet, iterators are not fully supported in Prusti.
This example is a draft and is meant as a possible real-world usage of <code>#[model]</code> in the near future.</p>
</blockquote>
<p>An example where a type model comes in handy is the <code>std::slice::Iter</code> struct from the standard library. We would like
to provide a specification for the <code>Iterator</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterator&lt;'a, T&gt; for std::slice::Iter&lt;'a, T&gt; {
    // ??? spec involving Iter ??? 
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>There is not really a way to provide a specification for this implementation, because <code>Iter</code>'s fields do not allow
a <a href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#65-71">straightforward specification</a>.</p>
<p>We can instead provide a model for <code>Iter</code> in the following way, using the <code>#[model]</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice::Iter;

#[model]
struct Iter&lt;'a, #[generic] T: Copy&gt; {
    position: usize,
    len: usize,
    data: GhostSeq&lt;T&gt; // Note: Assuming this is defined somewhere
}
<span class="boring">}
</span></code></pre></pre>
<p>This allows an instance of <code>Iter&lt;'_, T&gt;</code> to be modelled by the fields <code>position</code>, <code>len</code> and <code>data</code>.</p>
<p>The model can then be used in specifications:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ensures(result.model().position == 0)]
#[ensures(result.model().len == slice.len())]
#[trusted]
fn create_iter&lt;T&gt;(slice: &amp;[T]) -&gt; std::slice::Iter&lt;'_, T&gt; {
    slice.iter()
}

#[extern_spec]
impl&lt;T&gt; Iterator for std::slice::Iter&lt;'a, T&gt; {
    type Item = T;

<span class="boring">    [ensures( self .model().data.len == old( self .model().data.len)) )]
</span>    #[ensures(old(self.model().pos) &lt; self.model().data.len == &gt;
    ( result.is_some() &amp;&amp;
    result.unwrap() == self.model().data.lookup(old(self.model().pos))))
    ]
    // ... more ...
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customizable-counterexample"><a class="header" href="#customizable-counterexample">Customizable counterexample</a></h1>
<p>A counterexample for structs and enums can be formatted by annotating the type with <code>#[print_counterexample()]</code>. This is only avaible if the <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#unsafe_core_proof"><code>unsafe_core_proof</code></a> flag is set to <code>true</code>.</p>
<h2 id="syntax-structs"><a class="header" href="#syntax-structs">Syntax structs</a></h2>
<p>If a struct is annotated, the macro must have at least one argument and the first argument must be of type String and can contain an arbitrary number of curly brackets. The number of curly brackets must match the number of the remaining arguments. The remaining arguments must either be a field name, if the fields are named, or an index, if the fields are unnamed. A field can be used multiple times.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[print_counterexample(&quot;Custom message: {}, {}&quot;, field_1, field_2) ]
struct X {
    field_1: i32,
    field_2: i32,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="syntax-enums"><a class="header" href="#syntax-enums">Syntax enums</a></h2>
<p>If an enum is annotated, the macro must not contain any arguments. Each variant can be annotated in the exact same way as previously described. Only annotating a variant without the enum itself will result in a compile time error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[print_counterexample()]
enum X {
    #[print_counterexample(&quot;Custom message: {}, {}&quot;, 0, 1)]
    Variant1(i32, i32),
    #[print_counterexample(&quot;Custom message&quot;)]
    Variant2,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification-syntax"><a class="header" href="#specification-syntax">Specification syntax</a></h1>
<p>Prusti specifications are a superset of Rust boolean expressions. They must be deterministic and side-effect free. Therefore, they can only call only <a href="verify/pure.html">pure functions</a>. The extensions to Rust expressions are summarized below:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody>
<tr><td><a href="syntax.html#old-expressions"><code>old(...)</code></a></td><td>Value of expression in a previous state</td></tr>
<tr><td><a href="syntax.html#implications"><code>... ==&gt; ...</code></a></td><td>Implication</td></tr>
<tr><td><a href="syntax.html#quantifiers"><code>forall(...)</code></a></td><td>Universal quantifier</td></tr>
<tr><td><a href="syntax.html#quantifiers"><code>exists(...)</code></a></td><td>Existential quantifier</td></tr>
<tr><td><a href="syntax.html#specification-entailments"><code>... |= ...</code></a></td><td>Specification entailment</td></tr>
</tbody></table>
</div>
<h2 id="old-expressions"><a class="header" href="#old-expressions">Old expressions</a></h2>
<p>Old expressions are used to refer to the value that a memory location pointed at by a mutable reference had at the beginning of the function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prusti_contracts::*;

#[ensures(*x == old(*x) + 1)]
pub fn inc(x: &amp;mut u32) {
    *x += 1;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="implications"><a class="header" href="#implications">Implications</a></h2>
<p>Implications express a <a href="https://en.wikipedia.org/wiki/Material_conditional">relationship</a> between two boolean expressions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pure]
#[ensures(result ==&gt; self.len() == 0)]
#[ensures(!result ==&gt; self.len() &gt; 0)]
pub fn is_empty(&amp;self) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>There is no syntax for logical equivalences (&quot;if and only if&quot;), because this coincides with <code>==</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[pure]
#[ensures(result == (self.len() == 0))]
pub fn is_empty(&amp;self) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<p>Quantifiers are typically used for describing how a method call changes a container such as a vector:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
#[ensures(self.len() == old(self.len()))]
#[ensures(self.lookup(index) == value)]
#[ensures(
    forall(|i: usize|
        (0 &lt;= i &amp;&amp; i &lt; self.len() &amp;&amp; i != index)
        ==&gt; (self.lookup(i) == old(self.lookup(i)))
    )
)]
pub fn store(&amp;mut self, index: usize, value: i32) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>There may be multiple bound variables:</p>
<pre><code class="language-plain">forall(|x: isize, y: isize| ...)
</code></pre>
<p>The syntax of universal quantifiers is:</p>
<pre><code class="language-plain">forall(|&lt;bound variable&gt;: &lt;bound variable type&gt;, ...| &lt;filter&gt; ==&gt; &lt;expression&gt;)
</code></pre>
<p>and the syntax of existential ones:</p>
<pre><code class="language-plain">exists(|&lt;bound variable&gt;: &lt;bound variable type&gt;, ...| &lt;expression&gt;)
</code></pre>
<h2 id="specification-entailments-1"><a class="header" href="#specification-entailments-1">Specification entailments</a></h2>
<p>Specification entailments provide the contract for a given closure or function variable. See the <a href="verify/spec_ent.html">specification entailments</a> chapter for more details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
